<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Meteor - All in One.</title>

		<meta name="description" content="Meteor - Discover the easiest way to build amazing web and mobile apps in JavaScript">
		<meta name="author" content="Donatas Žukauskas">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">

				<section>
					<img src="img/logo_white.png" alt="Meteor logo">
					<h3>All in One.</h3>
				</section>

				<section>
					<section>
						<h3>So what is Meteor?</h3>
						<blockquote cite="https://www.meteor.com/">
						<img src="img/quote.svg" alt="Quote">
							Meteor is a complete open source platform for building web and mobile apps in pure JavaScript.
							<footer>— meteor.com</footer>
						</blockquote>
					</section>
					<section>
						<blockquote cite="http://javascriptissexy.com/learn-meteor-js-properly/">
						<img src="img/quote.svg" alt="Quote">
							Written in JavaScript on the Node.js platform, Meteor is an open-source Isomorphic Development Ecosystem (IDevE) for efficiently and painlessly developing web and mobile applications.
							<footer>— javascriptissexy.com</footer>
						</blockquote>
					</section>
					<section>
						<h3>Meteor is 2 things:</h3>
						<ol>
							<li>
								<strong>A library of packages</strong>: pre-written, self-contained modules that you might need in your app.
							</li>
							<li>
								<strong>A command-line tool</strong> called Meteor.
							</li>
						</ol>
					</section>
					<section>
						<h3>The Meteor Platform</h3>
						<ul>
							<li>
								<strong>Blaze</strong> - Reactive UI Library.
							</li>
							<li>
								<strong>Tracker</strong> - Reactive programming made easy.
							</li>
							<li>
								<strong>DDP</strong> - Websocket-based data protocol.
							</li>
							<li>
								<strong>Livequery</strong> - Live database connectors.
							</li>
							<li>
								<strong>Isobuild</strong> - Unified build system for browser, server, and mobile.
							</li>
							<li>
								<strong>Minimongo</strong> - In-memory JS reimplementations of MongoDB.
							</li>
						</ul>
					</section>
					<section>
						<h3>The Meteor Tool</h3>
						<ul>
							<li>
								Version Solver for managing dependency versions.
							</li>
							<li>
								Download any necessary packages.
							</li>
							<li>
								Build your app with Isobuild.
							</li>
							<li>
								Run it locally.
							</li>
							<li>
								Meteor deploy hosting service.
							</li>
							<li>
								File watching and live code reloads.
							</li>
						</ul>
					</section>
					<section>
						<img src="img/platform_overview.jpg" alt="Meteor Platform Overview">
					</section>

					<section>
						<img src="img/meteor_platform.png" alt="Meteor Platform">
					</section>
				</section>

				<section>
					<h3>Principles of Meteor</h3>
					<ol>
						<li>Data on the Wire.</li>
						<li>One Language.</li>
						<li>Database Everywhere.</li>
						<li>Latency Compensation.</li>
						<li>Full Stack Reactivity.</li>
						<li>Embrace the Ecosystem.</li>
						<li>Simplicity == Productivity.</li>
					</ol>
				</section>

				<section>
					<h3>Advantages of Meteor</h3>
					<ul>
						<li>Meteor is easy to learn.</li>
						<li>Good for beginners.</li>
						<li>Fast prototyping.</li>
						<li>Meteor's community is naturally beginner-friendly.</li>
						<li>Meteor is the future - The entire web is moving toward thick clients, reactive interfaces, and realtime APIs.</li>
						<li>Meteor even provides a free server sandbox to deploy and test your apps.</li>
					</ul>
				</section>

				<section>
					<h3>Code over configuration:</h3>
					<img src="img/mean_vs_meteor.png" alt="MEAN Stack vs Meteor.js">
				</section>

				<section>
					<h3>The MEAN Stack</h3>
					<ol>
						<li>Node.js</li>
						<li>Express</li>
						<li>Grunt or Gulp</li>
						<li>Mongoose</li>
						<li>A pub/sub driver</li>
						<li>Websocket</li>
						<li>Angular</li>
						<li>Karma</li>
						<li>account/oAuth libraries</li>
					</ol>
				</section>

				<section>
					<section>
						<h3>Browser</h3>
						<ul>
							<li>Tracker - The backbone of the reactive front-end.</li>
							<li>Spacebars - A derivation of Handlebars.</li>
							<li>Blaze - A reactive library built to marry Tracker &amp; Spacebars up to create live updating user interfaces.</li>
							<li>Minimongo - A client side mongo library that synchronizes data over DDP and allows the client to reactively consume mongo data.</li>
							<li>Session - A library to handle reactive UI state variables.</li>
						</ul>
					</section>
					<section>
						<h3>How Blaze Works</h3>
						<img src="img/blaze.jpg" alt="Blaze">
					</section>
					<section>
						<h3>Reactivity</h3>
						<p>You can write your code in a simple imperative style, and the result will be automatically recalculated whenever data changes that your code depends on.</p>
					</section>

					<section>
						<h3>Meteor's Reactivity</h3>
						<ul>
							<li>Reactive Sources</li>
							<li>Reactive Computations</li>
						</ul>
					</section>
					<section>
						<h3>Reactive Sources</h3>
						<ul>
							<li>Session Variables - You can define Session variables with Session.set() and retrieve them with Session.get(), and any session variable will be both global to your whole app, and reactive.</li>
							<li>Cursors - Cursors are what you get when you query your database with Collection.find(). They’re reactive, which is the reason why your app will change whenever the underlying data changes.</li>
							<li>Subscription’s ready() Method - </li>
							<li>When subscribing to a publication, it can be useful to know when the subscription is done loading (in other terms, when the client has safely received the data it requested). That’s where subscription.ready() comes in, and it too is reactive.</li>
							<li>Other Reactive Sources - Meteor.user(), Meteor.userId(), Meteor.status, as well as Meteor.loggingIn.</li>
							<li>ReactiveVar - The optional reactive-var package makes it possible to define your own, custom reactive variables.</li>
						</ul>
					</section>
					<section>
						<h3>Reactive Computations</h3>
						<ul>
							<li>Template Helpers - Template helpers (i.e. the {{variables}} you use inside templates) are themselves reactive computations. Any change to a reactive data source called from inside a helper will make the whole helper run again. </li>
							<li>Reactive Routing - Although not strictly “default” since it’s a third-party package, it’s worth nothing that Iron Router hooks are also reactive. </li>
							<li>Autorun: Custom Reactive Computations - Tracker.autorun() lets you define an arbitrary block of code that will run every time any one of its reactive sources change</li>
						</ul>
					</section>

					<section>
						<h3>Live HTML Templates</h3>
						<p>Meteor makes it easy to use your favorite HTML templating language along with Meteor's live page update technology. Just write your template as you normally would, and Meteor will take care of making it update in realtime.<p>
						<p>Meteor ships with a templating language called Spacebars, inspired by Handlebars. It shares some of the spirit and syntax of Handlebars, but it has been tailored to produce reactive Meteor templates when compiled.</p>
					</section>

					<section>
						<h3>Latency Compensation - Optimistic UI</h3>
						<img src="img/latency_compensation.png" alt="Latency Compensation">
					</section>

				</section>

				<section>
					<section>
						<h3>Communication layer</h3>
						<p>The communication layer is the real magic that binds the client and server together. EJSON is used to serialize and deserialize data moving across the wire via DDP.</p>
						<ul>
							<li>DDP (Distributed Data Protocol) - A protocol for sending data over websockets. Dubbed 'REST for websockets'.</li>
							<li>EJSON - An extension of JSON to support serializing more data types like Dates and Binary.</li>
						</ul>
					</section>

					<section>
						<h3>DDP</h3>
						<p>DDP is a protocol between a client and a server that supports two operations:</p>
						<ul>
							<li>Remote procedure calls by the client to the server.</li>
							<li>The client subscribing to a set of documents, and the server keeping the client informed about the contents of those documents as they change over time.</li>
							<li>DDP messages are JSON objects, with some fields specified to be EJSON.</li>
						</ul>
					</section>

					<section>
						<h3>EJSON</h3>
						<p>Meteor EJSON allows us to create custom types that are serialized and deserialized over the wire.</p>
						<p>EJSON data types are automatically serialized and deserialized over the wire when using Meteor methods or subscriptions.</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Server</h3>
						<p>The server is a Node.js app built with certain libraries in place to make the communication happen over DDP and EJSON to the front-end:</p>
						<ul>
							<li>Node.js - A javascript server.</li>
							<li>Connect - A library to output http responses from an app.</li>
							<li>Database Driver (Mongo) - A simple drive to interface with MongoDB data.</li>
							<li>Livequery - A library built to query and stream out Mongo data in a reactive way.</li>
							<li>Fibers/Futures - A wrapper library for Node.js, making it synchronous in an effort to reduce 'callback spaghetti'.</li>
						</ul>
					</section>
					<section>
						<h3>MongoDB</h3>
						<p>The Meteor team chose MongoDB as its datastore for its performance, scalability, and rich features for JSON.</p>
					</section>

					<section>
						<h3>Cursor</h3>
						<p>A cursor is just a way of storing information about a query, controlling execution of the query, and controlling iteration over the result set.</p>
						<p>If we call one of the iteration methods like fetch(), forEach() or map() on the cursor once the query is executed the results are cached.</p>
					</section>

					<section>
						<h3>Minimongo</h3>
						<p>Database everywhere - simply put, Meteor will take a subset of your database and copy it to the client. This has two big implications:</p>
						<ul>
							<li>First, instead of sending HTML code to the client, a Meteor app will send the actual, raw data and let the client deal with it (data on the wire).</li>
							<li>Second, you’ll be able to access that data instantaneously without having to wait for a round-trip to the server. And what’s even cooler is that Meteor will also do all the heavy lifting of keeping the client and server data in sync (latency compensation).</li>
						</ul>
					</section>

					<section>
						<img src="img/mongo.jpg" alt="MongoDB">
					</section>

					<section>
						<h3>Robomongo - Cross-platform MongoDB management tool</h3>
						<img src="img/robomongo.png" alt="Robomongo">
					</section>
				</section>

				<section>
					<section>
						<h3>Meteor Isobuild</h3>
						<p>Isobuild gathers all of the app's source files as well as any packages used by the app. It processes all of these inputs through the appropriate build phases for each target, such as transpiling, minifying, generating source maps, resolving package references, bundling assets, and so on.</p>
						<p>Isobuild can use npm and PhoneGap packages.</p>
					</section>
					<section>
						<p>The output of Isobuild is a set of runnable programs. For example, one simple Isobuild project could build into:</p>
						<ul>
							<li>A mobile app in iOS .ipa format for the Apple App Store, containing native iOS code.</li>
							<li>A mobile app in Android .apk format for the Google Play store, containing native Android code</li>
							<li>For a browser-based version of the app, a HTML5 resource bundle that can run in a browser and that targets HTML5 APIs</li>
							<li>A Unix daemon that provides the app's trusted server-side services, in the form of a ready-to-run tarball, targeting a particular machine type such as Linux on 64-bit Intel</li>
						</ul>
					</section>
					<section>
						<h3>Cordova</h3>
						<p>The Cordova integration is built into the command line tool and the package system. A simple meteor add-platform ios will get you started. The cordova app will be compiled into an app, but the hot code reload will bring over new code and cache it on the local device and load that next time instead.</p>
						<p>The Cordova interface is just built upon the same libraries as the browser, listed above.</p>
					</section>
				</section>

			<section>
				<section>
					<h3>File Load Order</h3>
					<ol>
						<li>HTML template files are always loaded before everything else</li>
						<li>Files beginning with main. are loaded last</li>
						<li>Files inside any lib/ directory are loaded next</li>
						<li>Files with deeper paths are loaded next</li>
						<li>Files are then loaded in alphabetical order of the entire path</li>
					</ol>
				</section>
				<section>
					<h3>Default file loading</h3>
					<p>If files are outside of the special directories listed below, Meteor does the following:</p>
					<ol>
						<li>HTML templates are compiled and sent to the client.</li>
						<li>CSS files are sent to the client. In production mode they are automatically concatenated and minified.</li>
						<li>JavaScript is loaded on the client and the server. You can use Meteor.isClient and Meteor.isServer to control where certain blocks of code run.</li>
					</ol>
					<p>If you want more control over which JavaScript code is loaded on the client and the server, you can use the special directories listed below.</p>
				</section>
				<section>
					<h3>Special Directories</h3>
					<p>Meteor is very flexible about how you structure the files in your app. It automatically loads all of your files, so there is no need to use &gt;script&lt; or &gt;link&lt; tags to include JavaScript or CSS.</p>
					<p>/Client</p>
					<p>/Server</p>
					<p>/Public</p>
					<p>/Private</p>
					<p>/Tests</p>
				</section>
				<section>
					<h3>Meteor Code</h3>
					<pre><code data-trim contenteditable>
if (Meteor.isClient) {
  console.log("Printed in browsers and mobile apps");
}

if (Meteor.isCordova) {
  console.log("Printed only in mobile cordova apps");
}

if (Meteor.isServer) {
  console.log("Printed on the server");
}
					</code></pre>
				
				</section>

				<section>
					<h3>Meteor Tracker</h3>
					<pre><code data-trim contenteditable>
var favoriteFood = "apples";
var favoriteFoodDep = new Tracker.Dependency;

var getFavoriteFood = function () {
  favoriteFoodDep.depend();
  return favoriteFood;
};

var setFavoriteFood = function (newValue) {
  favoriteFood = newValue;
  favoriteFoodDep.changed();
};

getFavoriteFood();
// "apples"

var handle = Tracker.autorun(function () {
  console.log("Your favorite food is " + getFavoriteFood());
});
// "Your favorite food is apples"

setFavoriteFood("mangoes");
// "Your favorite food is mangoes"
					</code></pre>
				</section>
			</section>
				
				<section>
					<section>
						<h3>What Specifically Does Meteor Offer Developers?</h3>
						<p>1. Meteor not only has a one-step installation for configuration and setup, but it also has an isomorphic API, which refers to using the same code on the frontend or backend, or even for mobile and web apps. This saves developers hours, perhaps even days and weeks, since there is no need for developers to wrestle with installing, configuring, and learning disparate libraries, module managers, multifarious APIs, drivers, and the like.</p>
					</section>
					<section>
						<p>2. It offers not only a front-end framework, like Backbone.js, but also a backend that seamlessly integrates with the frontend, and an easy-to-use API for communicating between the two; this provides developers with straightforward, no-fuss client-server data management (Collections, Models, etc.), server-side methods, and server session management. </p>
					</section>
					<section>
						<p>3. It provides not only bidirectional persistent communication (like socket.io), but also simplified reactive programming (like Bacon.js). The reactive programming library works in conjunction with the front-end framework to reactively (that is, instantly and continuously) update the UI whenever dependable data or variables change. Moreover, a Meteor community developer has implemented the Meteor front-end templating engine on the server, providing server side templating for Meteor. I should caution that this implementation is still in its infancy.</p>
					</section>
					<section>
						<p>4. It offers not only a stack that includes MongoDB database (with PostgreSQL and others planned), but also a front-end representation of MongoDB, called Minimongo, written entirely in JavaScript and available in every connected client. Meteor integrates the two (MongoDB on the backend and Minimongo on the frontend) in a well-conceived manner to mitigate latency, a concept called latency compensation. This results in considerably faster page updates and reloads, leading to a more satisfying user experience for developers and end users alike.</p>
					</section>
					<section>
						<p>5. It not only has a standardized Mongo API on both the frontend and backend, but it also has Oplog tailing for MongoDB, resulting in applications using substantially less server resources.</p>
					</section>
					<section>
						<p>6. It has a standard front-end router (created by a Meteor community member) that implements the best features from other popular front-end routers, and this router also provides server side routing and includes a familiar API like Express.js’s routing API, even allowing for connect middleware, RESTful endpoints, and the like.</p>
					</section>
					<section>
						<p>7. It has a lightweight front-end framework, Blaze.js, that has a templating engine that supersedes Handlebars.js, with a rendering engine similar to the WIP (Work in Project) HTMLBars. I should note that Blaze is neither as feature-rich and robust as Ember.js nor as expansive and extensible as Angular.js.</p>
					</section>
					<section>
						<p>8. Its integrated live browser reload (also known as hot code load and hot code push) not only automatically reloads your live web page whenever you make development changes on the frontend (HTML, CSS, images, JavaScript, etc.), but it also automatically refreshes just the necessary DOM elements on the page (without reloading the entire page), even when there are dependent changes to data on the backend (MongoDB) or frontend (Minimongo).</p>
					</section>
					<section>
						<p>9. It comes with requisite core packages to handle minification, preprocessing, concatenation, OAuth and custom user authentication (signup, login, forget password, etc.)., emailing, and coffeescripting; packages for popular frameworks like bootstrap, backbone, and jQuery; and even a package for SEO compatibility.</p>
					</section>
					<section>
						<p>10. It has its own command line tool that provides many of the functionalities provided by tools such as grunt, NPM, NVM, and the like. And if you add EventedMind’s em5 scaffolding tool, you also have some (though not most) of the functionalities provided by popular scaffolding tools prominent in Rails and Yeoman.</p>
					</section>
					<section>
						<p>11. It allows you to use NPM modules and it provides its own build system (a custom package manger) that transcends NPM, providing nearly all the worthwhile and crucial NPM functionalities and more. You can install third-party or custom Meteor packages from atmospherejs.com, the official repository for Meteor packages.</p>
					</section>
					<section>
						<p>12. It uses synchronous style coding, courtesy of the Fibers JavaScript library. This provides an easy to read code structure that many find more appealing than the asynchronous structure of callback functions, common in most JavaScript frameworks. I should caution that you must pay close attention to the section in the road map that deals with making async calls in Meteor because many seem to have trouble when making async calls in Meteor.</p>
					</section>
					<section>
						<p>13. It even provides support for mobile apps through Cordova Phonegap integration. You can easily deploy your Meteor app as a mobile app, using these simple commands:</p>
						<ul>
							<li>meteor run ios - runs your Meteor app in an iOS simulator and starts the server.</li>
							<li>meteor run android - runs your Meteor app in an Android simulator and starts the server.</li>
						</ul>
					</section>
					<section>
						<p>14. Meteor takes a proactive approach to security, reportedly with a core developer dedicated to addressing security.</p>
					</section>
					<section>
						<p>15. It has an official testing framework, Velocity,. With Velocity, you can use your favorite testing frameworks like Jasmine or Mocha, and run acceptance tests with Selenium. </p>
					</section>
				</section>

				<section>
					<section>
						<h3>Known Meteor Limitations</h3>
						<ul>
							<li>It supports only one database: MongoDB. (PostgreSQL?)</li>
							<li>It has no support for sharding on MongoDB.</li>
							<li>Its frontend framework does not have reusable UI components.</li>
							<li>It has only partial support for Redis.</li>
							<li>It does not work well with SEO, even with its Spiderable hack.</li>
							<li>Many [Atmospherejs.com, Meteor package management] packages don’t have the most vital information; the readme file for most packages is missing.</li>
							<li>Its front-end framework, Blaze.js, is neither as feature-rich and robust as Ember.js nor as expansive and extensible as Angular.js.</li>
						</ul>
					</section>

					<section>
						<h3>What kinds of applications can I not build with Meteor?</h3>
						<p>Meteor isn’t great for anything that’s mainly static content, like blogs or simple static sites. As a general rule, Meteor is great for apps, but not for sites. Another factor to consider is the fact that Meteor doesn’t do server-side content generation yet, meaning that your app won’t work without JavaScript enabled.</p>
					</section>
				</section>

				<section>
					<h3>Meteor Packages @ Atmosphere</h3>
					<table>
						<thead>
							<tr>
								<th>Date</th>
								<th>Packages</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>05.23</td>
								<td>5424</td>
							<tr>
							<tr>
								<td>06.04</td>
								<td>5639</td>
							<tr>
							<tr>
								<td>06.08</td>
								<td>5688</td>
							<tr>
							<tr>
								<td>06.15</td>
								<td>5833</td>
							<tr>
							<tr>
								<td>06.24</td>
								<td>6016</td>
							<tr>
							<tr>
								<td>06.29</td>
								<td>6099</td>
							<tr>
						</tbody>
					</table>
				</section>

				<section data-background="img/angular_bg.png">
					<h3>Angular Meteor</h3>
					<img src="img/angular.png" alt="Angular Meteor">
					<p>Meteor can be used as a backend platform for any reactive frontend technology.</p>
				</section>

				<section>
					<h3>Meteor Developer Subscription</h3>
					<ul>
						<li>Technical support</li>
						<li>Proactive alerts</li>
						<li>Guaranteed response</li>
						<li>Architectural review</li>
					</ul>
				</section>

				<section>
					<h3>MeteorPad</h3>
					<p>MeteorPad is a Meteor code playground, similar to JSFiddle or CodePen. You can edit and run Meteor code inside your browser, then save, fork, or share pads with others.</p>
				</section>

				<section>
					<h1>Reveal.js</h1>
					<h3>The HTML Presentation Framework</h3>
				</section>

				<section data-background="img/stars.jpg">
					<h1>THE END</h1>
					<h3>Questions?</h3>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
