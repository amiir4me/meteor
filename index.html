<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Meteor - All in One.</title>

		<meta name="description" content="Meteor - Discover the easiest way to build amazing web and mobile apps in JavaScript">
		<meta name="author" content="Donatas Å½ukauskas">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/beige.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<img src="img/logo.png" alt="Meteor logo">
					<h3>All in One.</h3>
				</section>

				<section>
					<section>
						<h3>So what is Meteor?</h3>
						<blockquote cite="https://www.meteor.com/">
							Meteor is a complete open source platform for building web and mobile apps in pure JavaScript.
						</blockquote>
					</section>
					<section>
						<blockquote cite="http://javascriptissexy.com/learn-meteor-js-properly/">
							Written in JavaScript on the Node.js platform, Meteor is an open-source Isomorphic Development Ecosystem (IDevE) for efficiently and painlessly developing web and mobile applications. The Meteor ecosystem seamlessly integrates all the components (tools, libraries, databases, and frameworks [frontend and backend]) necessary for building and deploying applications.
						</blockquote>
					</section>
					<section>
						<h3>Meteor is 2 things:</h3>
						<ol>
							<li>
								<strong>A library of packages</strong>: pre-written, self-contained modules that you might need in your app.
							</li>
							<li>
								<strong>A command-line tool</strong> called meteor.
							</li>
						</ol>
					</section>
					<section>
						<h3>The Meteor Platform</h3>
						<ul>
							<li>
								<strong>Blaze</strong> - Reactive UI Library.
							</li>
							<li>
								<strong>Tracker</strong> - Reactive programming made easy.
							</li>
							<li>
								<strong>DDP</strong> - Websocket-based data protocol.
							</li>
							<li>
								<strong>Livequery</strong> - Live database connectors.
							</li>
							<li>
								<strong>Isobuild</strong> - Unified build system for browser, server, and mobile.
							</li>
							<li>
								<strong>Minimongo</strong> - In-memory JS reimplementations of MongoDB.
							</li>
						</ul>
					</section>
					<section>
						<h3>The Meteor Tool</h3>
						<ul>
							<li>
								Solve package versions.
							</li>
							<li>
								Download any necessary packages.
							</li>
							<li>
								Build your app with Isobuild.
							</li>
							<li>
								Run it locally.
							</li>
							<li>
								Do a hot code push whenever the source files change.
							</li>
						</ul>
					</section>
				</section>

				<section>
					<h3>7 Principles of Meteor</h3>
					<ol>
						<li>Data on the Wire.</li>
						<li>One Language.</li>
						<li>Database Everywhere.</li>
						<li>Latency Compensation.</li>
						<li>Full Stack Reactivity.</li>
						<li>Embrace the Ecosystem.</li>
						<li>Simplicity == Productivity.</li>
					</ol>
				</section>

				<section>
					<h3>Advantages of Meteor</h3>
					<ul>
						<li>Meteor is easy to learn.</li>
						<li>Beginners - Focus on learning to code, rather than on configuration.</li>
						<li>Fast prototyping - You can install Meteor, create an example app, and deploy it online in just five commands in your terminal. Framework provides libraries for database access, templating and session management, code reuse.</li>
						<li>Meteor's community is naturally beginner-friendly.</li>
						<li>Meteor is the future - The entire web is moving toward thick clients, reactive interfaces, and realtime APIs.</li>
						<li>Meteor even provides a free server sandbox to deploy and test your apps.</li>
					</ul>
				</section>

				<section>
					<img src="img/meteor_mobile.png" alt="Meteor Mobile App">
				</section>

				<section>
					<h3>Code over configuration:</h3>
					<img src="img/mean_vs_meteor.png" alt="MEAN Stack vs Meteor.js">
				</section>

				<section>
					<h3>Meteor Packages @ Atmosphere</h3>
					<table>
						<thead>
							<tr>
								<th>Date</th>
								<th>Packages</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>05.23</td>
								<td>5424</td>
							<tr>
							<tr>
								<td>06.04</td>
								<td>5639</td>
							<tr>
							<tr>
								<td>06.08</td>
								<td>5688</td>
							<tr>
							<tr>
								<td>06.15</td>
								<td>5833</td>
							<tr>
						</tbody>
					</table>
				</section>

				<section>
					<h3>Meteor Code</h3>
					<pre><code data-trim contenteditable>
if (Meteor.isClient) {
  console.log("Printed in browsers and mobile apps");
}

if (Meteor.isCordova) {
  console.log("Printed only in mobile cordova apps");
}

if (Meteor.isServer) {
  console.log("Printed on the server");
}
					</code></pre>
				
				</section>

				<section>
					<section>
						<h3>Default file loading</h3>
						<p>If files are outside of the special directories listed below, Meteor does the following:</p>
						<ol>
							<li>HTML templates are compiled and sent to the client.</li>
							<li>CSS files are sent to the client. In production mode they are automatically concatenated and minified.</li>
							<li>JavaScript is loaded on the client and the server. You can use Meteor.isClient and Meteor.isServer to control where certain blocks of code run.</li>
						</ol>
						<p>If you want more control over which JavaScript code is loaded on the client and the server, you can use the special directories listed below.</p>
					</section>
					<section>
						<h3>Special Directories</h3>
						<p>Meteor is very flexible about how you structure the files in your app. It automatically loads all of your files, so there is no need to use &gt;script&lt; or &gt;link&lt; tags to include JavaScript or CSS.</p>
						<p>/Client</p>
						<p>/Server</p>
						<p>/Public</p>
						<p>/Private</p>
						<p>/Tests</p>
					</section>
				</section>

				<section>
					<h3>File Load Order</h3>
					<ol>
						<li>HTML template files are always loaded before everything else</li>
						<li>Files beginning with main. are loaded last</li>
						<li>Files inside any lib/ directory are loaded next</li>
						<li>Files with deeper paths are loaded next</li>
						<li>Files are then loaded in alphabetical order of the entire path</li>
					</ol>
				</section>

				<section>
					<section>
						<h3>Reactivity</h3>
						<p>You can write your code in a simple imperative style, and the result will be automatically recalculated whenever data changes that your code depends on.</p>
					</section>

					<section>
						<h3>Live HTML Templates</h3>
						<p>Meteor makes it easy to use your favorite HTML templating language along with Meteor's live page update technology. Just write your template as you normally would, and Meteor will take care of making it update in realtime.<p>
						<p>Meteor ships with a templating language called Spacebars, inspired by Handlebars. It shares some of the spirit and syntax of Handlebars, but it has been tailored to produce reactive Meteor templates when compiled.</p>
					</section>

				</section>

				<section>
					<img src="img/platform_overview.jpg" alt="Meteor Platform Overview">
				</section>

				<section>
					<h3>Ecosystem</h3>
					<p>Atmospherejs.com</p>
					<p>Meteor Development Group</p>
					<p>Galaxy - Meteor Hosting</p>
				</section>

				<section>
					<h3>MongoDB</h3>
					<p>The Meteor team chose MongoDB as its datastore for its performance, scalability, and rich features for JSON.</p>
				</section>

				<section>
					<h3>Robomongo - Shell-centric cross-platform MongoDB management tool</h3>
					<img src="img/robomongo.png" alt="Robomongo">
				</section>

				<section>
					<h3>Server</h3>
					<p>The server is a Node.js app built with certain libraries in place to make the communication happen over DDP and EJSON to the front-end:</p>
					<ul>
						<li>Node.js - A javascript server.</li>
						<li>Connect - A library to output http responses from an app.</li>
						<li>Database Driver (Mongo) - A simple drive to interface with MongoDB data.</li>
						<li>Livequery - A library built to query and stream out Mongo data in a reactive way.</li>
						<li>Fibers/Futures - A wrapper library for Node.js, making it synchronous in an effort to reduce 'callback spaghetti'.</li>
					</ul>
				</section>

				<section>
					<h3>Communication layer</h3>
					<p>The communication layer is the real magic that binds the client and server together. EJSON is used to serialize and deserialize data moving across the wire via DDP.</p>
					<ul>
						<li>DDP (Distributed Data Protocol) - A protocol for sending data over websockets. Dubbed 'REST for websockets'.</li>
						<li>EJSON - An extension of JSON to support serializing more data types like Dates and Binary.</li>
					</ul>
				</section>

				<section>
					<h3>Browser</h3>
					<p>The browser part of the platform is sent over with minimal html and some javascript that loads up the environment. A lot of code is built on jQuery and underscore.js as the foundation. While the server is synchonous, browsers and javascript are asynchonous by nature. Let's look at the libraries that help make up the client and it's reactive nature:</p>
					<ul>
						<li>Tracker - The backbone of the reactive front-end. It is the reactive 'glue' for any tracker aware libraries you build.</li>
						<li>Spacebars - A derivation of Handlebars, built to be reactive.</li>
						<li>Blaze - A reactive library built to marry Tracker &amp; Spacebars up to create live updating user interfaces. Similar to Angular, Backbone, Ember, React, Polymer, or Knockout - just easier.</li>
						<li>Minimongo - A client side mongo library that synchronizes data over DDP and allows the client to reactively consume mongo data.</li>
						<li>Session - A library to handle reactive UI state variables, nothing like a session in Rails, PHP or Node.js.</li>
					</ul>
				</section>

				<section id="themes">
					<h3>Cordova</h3>
					<p>The Cordova integration is built into the command line tool and the package system. A simple meteor add-platform ios will get you started. The cordova app will be compiled into an app, but the hot code reload will bring over new code and cache it on the local device and load that next time instead.</p>
					<p>The Cordova interface is just built upon the same libraries as the browser, listed above.</p>
				</section>

				<section>
					<h3>Packages</h3>
					<p>I mentioned ISOBuild above, but I wanted to reiterate how much power can come from a package you add to Meteor.js. The package system has a few 'core' packages that can easily be added, like accounts-ui or accounts-google. These packages are little libraries built to take of things like login and authentication, oauth authorization, etc. You also have user created packages on Atmosphere, like iron:router, which has become the defacto router for 99% of all Meteor.js apps.</p>
					<p>The fact that you can deliver small bits of functionality in a nicely encapsulated and automated fashion brings true power to this platform.</p>
				</section>

				<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
					<h3>Why building your own platform is a bad idea</h3>
					<ul>
						<li>Node.js</li>
						<li>Express</li>
						<li>Grunt or Gulp</li>
						<li>Mongoose mongo driver</li>
						<li>A pub/sub driver (I hear there is a decent redis one)</li>
						<li>Websocket (which one?)</li>
						<li>Angular</li>
						<li>Karma</li>
						<li>account/oAuth libraries</li>
					</ul>
				</section>

				<section data-transition="slide" data-background="#b5533c" data-background-transition="zoom">
					<h2>Background Transitions</h2>
					<p>
						You can override background transitions per-slide.
					</p>
					<pre><code style="word-wrap: break-word;">&lt;section data-background-transition="zoom"&gt;</code></pre>
				</section>

				<section>
					<h2>Pretty Code</h2>
					<pre><code data-trim contenteditable>
function linkify( selector ) {
  if( supports3DTransforms ) {

    var nodes = document.querySelectorAll( selector );

    for( var i = 0, len = nodes.length; i &lt; len; i++ ) {
      var node = nodes[i];

      if( !node.className ) {
        node.className += ' roll';
      }
    }
  }
}
					</code></pre>
					<p>Code syntax highlighting courtesy of <a href="http://softwaremaniacs.org/soft/highlight/en/description/">highlight.js</a>.</p>
				</section>

				<section>
					<h2>Marvelous List</h2>
					<ul>
						<li>No order here</li>
						<li>Or here</li>
						<li>Or here</li>
						<li>Or here</li>
					</ul>
				</section>

				<section>
					<h2>Fantastic Ordered List</h2>
					<ol>
						<li>One is smaller than...</li>
						<li>Two is smaller than...</li>
						<li>Three!</li>
					</ol>
				</section>

				<section>
					<h2>Tabular Tables</h2>
					<table>
						<thead>
							<tr>
								<th>Item</th>
								<th>Value</th>
								<th>Quantity</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Apples</td>
								<td>$1</td>
								<td>7</td>
							<tr>
							<tr>
								<td>Lemonade</td>
								<td>$2</td>
								<td>18</td>
							<tr>
							<tr>
								<td>Bread</td>
								<td>$3</td>
								<td>2</td>
							<tr>
						</tbody>
					</table>
				</section>

				<section>
					<h3>Comprehensive and integrated ecosystem</h3>
					<p>Meteor offers much more than just a front-end, a backend, or a combination of the two with some libraries. It offers everything you need to build web applications: a seamlessly integrated ecosystem that includes frameworks, libraries, database, tools, and more.</p>
				</section>

				<section>
					<section>
						<h3>What Specifically Does Meteor Offer Developers?</h3>
						<p>1. Meteor not only has a one-step installation for configuration and setup, but it also has an isomorphic API, which refers to using the same code on the frontend or backend, or even for mobile and web apps. This saves developers hours, perhaps even days and weeks, since there is no need for developers to wrestle with installing, configuring, and learning disparate libraries, module managers, multifarious APIs, drivers, and the like.</p>
					</section>
					<section>
						<p>2. It offers not only a front-end framework, like Backbone.js, but also a backend that seamlessly integrates with the frontend, and an easy-to-use API for communicating between the two; this provides developers with straightforward, no-fuss client-server data management (Collections, Models, etc.), server-side methods, and server session management. </p>
					</section>
					<section>
						<p>3. It provides not only bidirectional persistent communication (like socket.io), but also simplified reactive programming (like Bacon.js). The reactive programming library works in conjunction with the front-end framework to reactively (that is, instantly and continuously) update the UI whenever dependable data or variables change. Moreover, a Meteor community developer has implemented the Meteor front-end templating engine on the server, providing server side templating for Meteor. I should caution that this implementation is still in its infancy.</p>
					</section>
					<section>
						<p>4. It offers not only a stack that includes MongoDB database (with PostgreSQL and others planned), but also a front-end representation of MongoDB, called Minimongo, written entirely in JavaScript and available in every connected client. Meteor integrates the two (MongoDB on the backend and Minimongo on the frontend) in a well-conceived manner to mitigate latency, a concept called latency compensation. This results in considerably faster page updates and reloads, leading to a more satisfying user experience for developers and end users alike.</p>
					</section>
					<section>
						<p>5. It not only has a standardized Mongo API on both the frontend and backend, but it also has Oplog tailing for MongoDB, resulting in applications using substantially less server resources.</p>
					</section>
					<section>
						<p>6. It has a standard front-end router (created by a Meteor community member) that implements the best features from other popular front-end routers, and this router also provides server side routing and includes a familiar API like Express.jsâs routing API, even allowing for connect middleware, RESTful endpoints, and the like.</p>
					</section>
					<section>
						<p>7. It has a lightweight front-end framework, Blaze.js, that has a templating engine that supersedes Handlebars.js, with a rendering engine similar to the WIP (Work in Project) HTMLBars. I should note that Blaze is neither as feature-rich and robust as Ember.js nor as expansive and extensible as Angular.js.</p>
					</section>
					<section>
						<p>8. Its integrated live browser reload (also known as hot code load and hot code push) not only automatically reloads your live web page whenever you make development changes on the frontend (HTML, CSS, images, JavaScript, etc.), but it also automatically refreshes just the necessary DOM elements on the page (without reloading the entire page), even when there are dependent changes to data on the backend (MongoDB) or frontend (Minimongo).</p>
					</section>
					<section>
						<p>9. It comes with requisite core packages to handle minification, preprocessing, concatenation, OAuth and custom user authentication (signup, login, forget password, etc.)., emailing, and coffeescripting; packages for popular frameworks like bootstrap, backbone, and jQuery; and even a package for SEO compatibility.</p>
					</section>
					<section>
						<p>10. It has its own command line tool that provides many of the functionalities provided by tools such as grunt, NPM, NVM, and the like. And if you add EventedMindâs em5 scaffolding tool, you also have some (though not most) of the functionalities provided by popular scaffolding tools prominent in Rails and Yeoman.</p>
					</section>
					<section>
						<p>11. It allows you to use NPM modules and it provides its own build system (a custom package manger) that transcends NPM, providing nearly all the worthwhile and crucial NPM functionalities and more. You can install third-party or custom Meteor packages from atmospherejs.com, the official repository for Meteor packages.</p>
					</section>
					<section>
						<p>12. It uses synchronous style coding, courtesy of the Fibers JavaScript library. This provides an easy to read code structure that many find more appealing than the asynchronous structure of callback functions, common in most JavaScript frameworks. I should caution that you must pay close attention to the section in the road map that deals with making async calls in Meteor because many seem to have trouble when making async calls in Meteor.</p>
					</section>
					<section>
						<p>13. It even provides support for mobile apps through Cordova Phonegap integration. You can easily deploy your Meteor app as a mobile app, using these simple commands:</p>
						<ul>
							<li>meteor run ios - runs your Meteor app in an iOS simulator and starts the server.</li>
							<li>meteor run android - runs your Meteor app in an Android simulator and starts the server.</li>
						</ul>
					</section>
					<section>
						<p>14. Meteor takes a proactive approach to security, reportedly with a core developer dedicated to addressing security.</p>
					</section>
					<section>
						<p>15. It has an official testing framework, Velocity,. With Velocity, you can use your favorite testing frameworks like Jasmine or Mocha, and run acceptance tests with Selenium. </p>
					</section>
				</section>

				<section>
					<h3>FAQ</h3>
					<p>Q: What kinds of applications can I not build with Meteor?</p>
					<p>â¨A: Sacha Greif, Coauthor of DiscoverMeteor.</p>
					<p>Meteor isnât great for anything thatâs mainly static content, like blogs or simple static sites. As a general rule, Meteor is great for apps, but not for sites. Another factor to consider is the fact that Meteor doesnât do server-side content generation yet, meaning that your app wonât work without JavaScript enabled.</p>
				</section>

				<section>
					<h3>Known Meteor Limitations</h3>
					<ul>
						<li>It supports only one database: MongoDB. (PostgreSQL?)</li>
						<li>It has no support for sharding on MongoDB.</li>
						<li>Its frontend framework does not have reusable UI components.</li>
						<li>It has only partial support for Redis.</li>
						<li>It does not work well with SEO, even with its Spiderable hack.</li>
						<li>Many [Atmospherejs.com, Meteor package management] packages donât have the most vital information; the readme file for most packages is missing.</li>
						<li>Its front-end framework, Blaze.js, is neither as feature-rich and robust as Ember.js nor as expansive and extensible as Angular.js.</li>
					</ul>
				</section>

				<section>
					<h3>Event Loop and Node.js</h3>
					<p>Meteor is built on top of Node.js, so we canât forget the Event Loop. Node.js runs on a single thread, and thanks to the Event Loop and event-driven programming, program execution isnât blocked by I/O activities (network and disk, mainly). Instead, we provide a callback function that is run after the I/O completes, and the rest of the program continues to run.</p>
				</section>

				<section>
					<h3>Fibers</h3>
					<p>Now you know how the Event Loop works, and how efficient it is. But there is a problem: Callbacks. Callbacks make Node.js code difficult to reason about (some describe it as callback soup). Error handling and nested callbacks are uncomfortable to write, and their existence makes code difficult to maintain and scale. Thatâs why some say Node.js is hard to learn (and use).</p>
					<p>Meteor uses Fibers, and implements APIs on top of it.</p>
				</section>

				<section>
					<p>Fibers provides an abstraction layer for the Event Loop that allows us to execute functions (tasks) in sequence. It allows us to write asynchronous code without callbacks. We get the best of both worldsâasynchronous efficiency with synchronous-style coding. Behind the scenes, Fibers takes care of dealing with the Event Loop. Fibers is really good if you use it correctly (Meteor does it well). Also, the overhead caused by Fibers is negligible.</p>
				</section>

				<section>
					<h3>How Meteor Uses Fibers</h3>
					<p>Meteor abstracts Fibers with its APIs, allowing you to write your app without callbacks. The best part is that you can write your code this way and be completely oblivious to Fibers. It just works.</p>
				</section>

				<section>
					<p>Meteor creates a new Fiber for each and every request (DDP Request) made from the client. By default, Meteor executes one request at a time for each client, meaning one Fiber for each client at a time. But you can change that.</p>
					<p>Fibers is the one of the best reasons Meteor is so popular. Since it allows us to write Node.js apps without callbacks, it has attracted many developers who hated Node.js for that reason.</p>
				</section>

				<section>
					<h3>Meteor-npm</h3>
					<p>With Meteor you only can use npm modules inside packages. You can't directly use npm modules with meteor apps. This package solves that issue :)</p>
				</section>

				<section>
					<h3>DDP</h3>
					<p>DDP is a protocol between a client and a server that supports two operations:</p>
					<ul>
						<li>Remote procedure calls by the client to the server.</li>
						<li>The client subscribing to a set of documents, and the server keeping the client informed about the contents of those documents as they change over time.</li>
					</ul>
				</section>

				<section>
					<h3>DDP</h3>
					<p>A protocol for sending data over websockets. Dubbed 'REST for websockets'.</p>
					<p>DDP messages are JSON objects, with some fields specified to be EJSON. Each one has a msg field that specifies the message type, as well as other fields depending on message type.</p>
				</section>

				<section style="text-align: left;">
					<h1>THE END</h1>
					<p>Questions?</p>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
